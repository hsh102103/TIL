# Selection Sort(선택정렬)
[정의](#정의)  
[과정](#과정ascending)  
[시간복잡도](#시간-복잡도)  
[특징](#특징)

## 정의
**자리를 선택하고 그 자리에 오는 값을 찾는 것**  
정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식  

## 과정
1. 배열의 인덱스를 선택한다.
2. 선택한 인덱스 이후의 값들 중 최소값을 찾는다.
3. 1에서 선택한 인덱스의 값과 바꾼다.
4. 인덱스를 이동하며 1~3과정을 반복한다.
```java
    void selectionSort(int[] arr) {
        int indexMin, temp;
        for (int i = 0; i < arr.length-1; i++) {
            indexMin = i;
            for (int j = i+1; j < arr.length; j++) {
                if(arr[j] < arr[indexMin]) {
                    indexMin = j;
                }
            }
            // swap(arr[indexMin, arr[i]])
            temp = arr[indexMin];
            arr[indexMin] = arr[i];
            arr[i] = temp;
        }
        System.out.println(Arrays.toString(arr));
    }
```
1. index를 선택한다.
2. index+1번째 원소부터 index의 값과 비교하다.
3. 배열을 끝까지 확인하며 가장 작은 값을 찾는다.
4. index의 값과 찾은 가장 작은 값의 위치를 바꾼다.
5. index를 1칸 이동시켜 1~4를 반복한다.

## 시간 복잡도
**O(n^2)**  
(n-1) + (n-2) + (n-3) + ... + 2 + 1 => n(n-1)/2

## 특징

### 장점
- 알고리즘이 단순하다.
- 정렬을 위한 비교 횟수는 많지만, Bubble Sort에 비해 실제로 교환하는 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료 상태에서 비교적 효율적이다.
- 선택 정렬은 알고리즘이 단순하며 사용할 수 있는 메모리가 제한적인 경우에 사용시 성능 상의 이점이 있다.

## 개선방법
- 이중 선택 정렬
    - 한 번의 탐색에서 최솟값과 최댓값을 같이 찾는 방법이다. 탐색 횟수가 절반으로 줄어들게 된다.
- 탐색을 응용한 개선
    - 한 번의 탐색 때 동일한 값이 있다면 함께 정렬하는 방법이다. 즉, 최솟값과 같은 같들이 있다면 탐색된 것으로 보고 미리 정렬한다.