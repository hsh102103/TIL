# 2019 카카오 개발자 겨울 인턴쉽 - 크레인 인형 뽑기 (프로그래머스)

# [문제](https://school.programmers.co.kr/learn/courses/30/lessons/64061)

## 문제 설명

주어지는 board 2차원 배열에서 moves의 원소를 세로(열)로 가지는 값들 중 0이 아닌 값을 찾아 하나씩 꺼내서 스택형태의 바구니에 담습니다.  
이때 바로 같은 인형 2개가 붙어있을 경우, 바구니에서 사라집니다. moves의 원소를 모두 확인하였을 때 바구니에서 사라지는 인형의 총 갯수를 구하는 문제입니다.

## 제한 조건

board 배열의 크기는 5x5 이상 30x30 이하입니다.  
board 배열의 원소들의 값은 0 이상 100 이하입니다. 이때, 0은 빈칸을 의미합니다.

moves 배열은 1000이하의 자연수입니다.  
moves 배열의 각 원소들의 값은 board배열의 가로(행) 크기 이하의 자연수입니다.

## 특이 사항

이 문제에서는 뽑은 인형들이 차례대로 바구니에 담기게 되는데, 만약 같은 인형이 연속으로 들어가게되면 그 이전의 것(i-2)이 다음 뽑았을 때의 비교대상이 됩니다.  
그렇기 때문에 뽑은 인형들의 순서를 기억하고 있어야합니다.

## 풀이 설명

인형들의 순서를 기억해야하기 때문에 뽑은 인형들의 번호를 배열에 담아주어야 합니다.  
뽑은 이후에는 가장 마지막에 담은 인형의 번호와 지금 뽑은 인형의 번호를 비교해야합니다.
위의 2가지 조건을 만족시키기 위하여 LIFO(후입선출) 구조를 가지는 Stack 자료구조를 활용하였습니다.

## 시간 복잡도

**O(NM)**
2차원 배열을 탐색하는데, 세로는 moves 배열 원소의 값으로 고정됩니다.  
따라서 N\*M만큼 반복되며, 30\*1000 이기 때문에 구현에 무리가 없다고 판단하였습니다.

## 공간 복잡도

## 어려웠던 부분

인형이 바구니에서 터져 사라지면 그 이전에 뽑았었던 인형 번호를 알고 있어야된다는 부분이 핵심이었던 것 같습니다.

### 소요 시간

20분

## 소스코드

```java
import java.util.*;
class Solution {
    /**
     * @param board 게임 화면의 격자의 상태가 담긴 정사각형 모양의 2차원 정수 배열
     * @param moves 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열
     * @return 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수
     */
    public int solution(int[][] board, int[] moves) {
        int answer = 0;

        Stack<Integer> stack = new Stack<>(); //뽑은 인형을 담아두기 위한 Stack 선언

        for(int move: moves) { // moves 배열의 원소를 차례대로 확인
            for(int i = 0; i<board.length; i++) { // board에서 세로를 move로 가지는 값들을 확인
                // 0이라면 -> 비어있는 공간이라면 넘어가기
                // moves에 담긴 값들은 1부터 시작하기 때문에 0부터 시작하는 배열과 맞춰주기 위해 -1
                if(board[i][move-1] == 0) continue;
                int pick = board[i][move-1]; // 뽑은 인형 번호 저장
                board[i][move-1] =0; // 뽑은 공간은 0으로 저장
                if(stack.isEmpty() || pick != stack.peek()) { // stack이 비어있거나 pick과 다른 경우
                    stack.add(pick); // stack에 pick을 담기만 해준다.
                    break;
                }else { // stack에 가장 마지막으로 들어간 값이 pick과 같은 경우
                    answer += 2; // 2개가 모일때마다 사라지기때문에 return할 값에 +2
                    stack.pop(); // stack에서 확인한 값을 제거해준다.
                    break;
                }
            }
        }
        return answer;
    }
}

```
